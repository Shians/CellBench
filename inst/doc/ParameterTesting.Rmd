---
title: "Use case: Benchmarking method parameters"
author: "Shian Su"
date: "`r Sys.Date()`"
output: BiocStyle::pdf_document
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(CellBench)
library(dplyr)
library(ggplot2)
set_cellbench_threads(4)
```

# Introduction

This use case shows how to test a range of parameters for a given method. We will use the CelSeq2 mRNA mixture data and apply knn-smooth with various `k` parameter to see its effects on the output.

# Setting up benchmark

```{r}
library(CellBench)
library(dplyr)
library(ggplot2)
```

We load in the data and create a list of 1 SingleCellExperiment object.

```{r}
cellbench_mrna_mix_data <- load_mrna_mix_data()

data <- list(
    mrna_mix_celseq = cellbench_mrna_mix_data$mrna_mix_celseq
)

str(data, 1)
```

We need to write some small wrappers to help run pipelines and make methods uniform in input and output. This is necessary because each step of analysis should take in the same type of data and output the same type of data, however different methods may differ in how they are called, how many steps need to run and what they output. Wrappers help manage this, in this example we want our normalisation step to take in a SingleCellExperiment and output a normalised count matrix. The imputation step should take a count matrix and return an imputed counts matrix.

```{r}
# take in a SingleCellExperiment and return a scran normalised expression matrix
scran_norm_expr <- function(x) {
    stopifnot(is(x, "SingleCellExperiment"))

    x <- scran::computeSumFactors(x)
    x <- scater::normalize(x, return_log = FALSE)

    SingleCellExperiment::normcounts(x)
}

# take in an expression matrix and return the imputed expression matrix
impute_knn_smooth <- function(expr, k) {
    source("https://raw.githubusercontent.com/yanailab/knn-smoothing/master/knn_smooth.R")
    smoothed_mat <- knn_smoothing(mat = expr, k = k)
    smoothed_mat
}
```

We then create the lists of functions to use with CellBench. We only have one normalisation method, but for imputation we can create a series of partially applied functions with different `k` parameters. Here assuming we have `f(x, y)`, `partial(f, y = 1)` is equivalent to `function(x) f(x, y = 1)`, partial application "fills in" parameter values and returns a function that can be called.

```{r}
norm_method <- list(
    scran = scran_norm_expr
)

# identity simply returns its argument, here it's used to represent no imputation
impute_method <- list(
    "none" = identity,
    "partial(k = 4)" = partial(impute_knn_smooth, k = 4),
    "partial(k = 8)" = partial(impute_knn_smooth, k = 8),
    "partial(k = 16)" = partial(impute_knn_smooth, k = 16),
    "partial(k = 32)" = partial(impute_knn_smooth, k = 32)
)
```

```{r}
res <- data %>%
    apply_methods(norm_method)
```

```{r}
res <- res %>%
    apply_methods(impute_method)
```

```{r}
res <- res %>%
    dplyr::mutate(result = lapply(result, function(x) log2(x + 1)))
class(res) <- append("benchmark_tbl", class(res))
```


```{r}
dim_red <- list(
    pca = compute_pca
)

res <- res %>%
    apply_methods(dim_red)
```

```{r}
append_anno <- function(data_key, result) {
    mRNA_amount <- colData(cellbench_mrna_mix_data$mrna_mix_celseq)$mRNA_amount

    truth <- with(
        colData(cellbench_mrna_mix_data$mrna_mix_celseq),
        paste(H2228_prop, H1975_prop, HCC827_prop)
    )

    result %>%
        tibble::add_column(mRNA_amount, .before = TRUE) %>%
        tibble::add_column(truth, .before = TRUE)
}
```

```{r}
annotated_res <- res %>%
    dplyr::mutate(data_key = paste(data)) %>%
    dplyr::mutate(result = map2(data_key, result, append_anno)) %>%
    dplyr::select(-data_key)

plot_df <- tidyr::unnest(annotated_res %>% dplyr::filter(norm_method == "scran"))

plot_df %>%
    ggplot(aes(x = Dim1, y = Dim2, col = truth)) +
    geom_point() +
    facet_wrap(~impute_method, nrow = 2) +
    ggtitle("KNN Smooth Imputation")
```

# Conclusion


